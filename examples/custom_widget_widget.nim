import nimqt
import nimqt/[qpushbutton, qlistwidget, qgridlayout, qboxlayout]

# In every module imports nimqt, we have to add a nimqt.init statement!
nimqt.init

# In this module, we create a pointless custom widget.
# It contains a list with options, and a yes and no button.
# The no button will emit the on_no_clicked signal, while the yes button will emit the
# on_yes_clicked, together with the selected item.
# 
# This module can be imported in other modules, by doing
# ```
# import custom_widget_widget
# custom_widget_widget.import_OptionSelector()
# ```
# The last line will generate the necessary c++ code so you can use the type.
# The import_${TYPE} is generated by inheritQObject.

# Create the object. Note that we track the list and btnYes, so we can access them easily later on.
inheritQObject(OptionSelector, QWidget):
    var list:ptr QListWidget
    var btnYes:ptr QPushButton
    
    signal on_yes_clicked(option:QString)
    signal on_no_clicked()
    
    slot_defer btn_no_clicked(): emit this.on_no_clicked()
    slot_defer btn_yes_clicked(): emit this.on_yes_clicked(this.list.currentItem.text)
    slot_defer row_changed(row:int): this.btnYes.setEnabled(row>=0)

# Constructor for our widget.
proc createOptionSelector*(xs:seq[string]): ptr OptionSelector =
    result=newOptionSelector()
    result.makeLayout():
        - newQWidget():
            - newQGridLayout():
                - newQListWidget() as list at (0,0,2,1):
                    connect(SIGNAL "currentRowChanged(int)", result, SLOT "row_changed(int)")
                - newQPushButton(Q"Yes") as btnYes at (0,1):
                    setEnabled(false)
                    connect(SIGNAL "clicked()", result, SLOT "btn_yes_clicked()")
                - newQPushButton(Q"No") as btnNo at (1,1):
                    connect(SIGNAL "clicked()", result, SLOT "btn_no_clicked()")
    
    result.list=list
    result.btnYes=btnYes
    for x in xs: list.addItem Q(x)

nimqt.insertAllSlotImplementations
